<!DOCTYPE html>
<html>
<head>
    <title>Claw Machine Game</title>
    <style>
        body { margin: 0; }
        .view-container {
            display: flex;
            height: 100vh;
        }
        #mainView {
            flex: 2;
            height: 100%;
        }
        #topView {
            flex: 1;
            height: 100%;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        .score {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<div class="view-container">
    <div id="mainView"></div>
    <div id="topView"></div>
</div>
<div class="controls">
    Click and drag to move claw | Press SPACE to drop
</div>
<div class="score">
    Prizes Collected: <span id="scoreValue">0</span>
</div>
<script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.1/three.module.min.js';

    let mainCamera, topCamera, scene, renderer;
    let claw, clawBase, prizes = [];
    let isDragging = false;
    let mouseX = 0, mouseY = 0;
    let clawState = 'idle'; // idle, dropping, rising, holding
    let clawSpeed = 0.05;
    let initialClawHeight = 5;
    let score = 0;
    let heldPrize = null;
    let clawBox = new THREE.Box3();
    let prizeBoxes = [];

    init();
    animate();

    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        // Renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.getElementById('mainView').appendChild(renderer.domElement);

        // Main camera
        mainCamera = new THREE.PerspectiveCamera(75, (window.innerWidth * 2/3) / window.innerHeight, 0.1, 1000);
        mainCamera.position.set(0, 8, 12);
        mainCamera.lookAt(0, 0, 0);

        // Top camera
        topCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 1000);
        topCamera.position.set(0, 20, 0);
        topCamera.lookAt(0, 0, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        createCabinet();
        createClaw();
        createPrizes();

        // Event listeners
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('resize', onWindowResize);
    }

    function createCabinet() {
        const wallGeometry = new THREE.BoxGeometry(12, 10, 12);
        const wallMaterial = new THREE.MeshPhongMaterial({
            color: 0x8B4513,
            transparent: true,
            opacity: 0.3
        });
        const cabinet = new THREE.Mesh(wallGeometry, wallMaterial);
        cabinet.position.y = 5;
        scene.add(cabinet);

        const baseGeometry = new THREE.BoxGeometry(12, 1, 12);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.5;
        scene.add(base);
    }

    function createClaw() {
        clawBase = new THREE.Group();
        const baseGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        clawBase.add(base);

        claw = new THREE.Group();
        const armGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
        const armMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });

        for (let i = 0; i < 4; i++) {
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.y = -0.25;
            arm.rotation.y = (i * Math.PI) / 2;
            arm.position.x = Math.sin(arm.rotation.y) * 0.3;
            arm.position.z = Math.cos(arm.rotation.y) * 0.3;
            claw.add(arm);
        }

        clawBase.add(claw);
        clawBase.position.y = initialClawHeight;
        scene.add(clawBase);
    }

    function createPrizes() {
        const prizeGeometries = [
            new THREE.SphereGeometry(0.5),
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.ConeGeometry(0.4, 1, 8)
        ];

        const prizeMaterials = [
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
            new THREE.MeshPhongMaterial({ color: 0x00ff00 }),
            new THREE.MeshPhongMaterial({ color: 0x0000ff })
        ];

        for (let i = 0; i < 10; i++) {
            const randomIndex = Math.floor(Math.random() * prizeGeometries.length);
            const prize = new THREE.Mesh(
                prizeGeometries[randomIndex],
                prizeMaterials[randomIndex]
            );

            prize.position.x = (Math.random() - 0.5) * 8;
            prize.position.y = 0.5;
            prize.position.z = (Math.random() - 0.5) * 8;
            prize.userData.value = (randomIndex + 1) * 100; // Prize value
            prize.userData.isCollected = false;

            prizes.push(prize);
            prizeBoxes.push(new THREE.Box3().setFromObject(prize));
            scene.add(prize);
        }
    }

    function checkCollision() {
        clawBox.setFromObject(claw);

        for (let i = 0; i < prizes.length; i++) {
            const prize = prizes[i];
            if (!prize.userData.isCollected) {
                prizeBoxes[i].setFromObject(prize);
                if (clawBox.intersectsBox(prizeBoxes[i])) {
                    return prize;
                }
            }
        }
        return null;
    }

    function updatePrizePosition() {
        if (heldPrize) {
            heldPrize.position.set(
                clawBase.position.x,
                clawBase.position.y - 1,
                clawBase.position.z
            );
        }
    }

    function collectPrize() {
        if (heldPrize) {
            score += heldPrize.userData.value;
            document.getElementById('scoreValue').textContent = score;
            heldPrize.userData.isCollected = true;
            scene.remove(heldPrize);
            heldPrize = null;
        }
    }

    function onMouseDown(event) {
        isDragging = true;
    }

    function onMouseMove(event) {
        if (isDragging && clawState === 'idle') {
            const movementX = event.movementX || 0;
            const movementZ = event.movementY || 0;

            clawBase.position.x = THREE.MathUtils.clamp(
                clawBase.position.x + movementX * 0.01,
                -5,
                5
            );
            clawBase.position.z = THREE.MathUtils.clamp(
                clawBase.position.z + movementZ * 0.01,
                -5,
                5
            );
        }
    }

    function onMouseUp() {
        isDragging = false;
    }

    function onKeyDown(event) {
        if (event.code === 'Space' && clawState === 'idle') {
            clawState = 'dropping';
        }
    }

    function onWindowResize() {
        mainCamera.aspect = (window.innerWidth * 2/3) / window.innerHeight;
        mainCamera.updateProjectionMatrix();

        const aspectRatio = window.innerWidth / window.innerHeight;
        const width = 10 * aspectRatio;
        topCamera.left = -width;
        topCamera.right = width;
        topCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Update claw state and check for collisions
        if (clawState === 'dropping') {
            clawBase.position.y -= clawSpeed;
            if (clawBase.position.y <= 1) {
                const collidedPrize = checkCollision();
                if (collidedPrize) {
                    heldPrize = collidedPrize;
                    clawState = 'holding';
                }
                clawState = 'rising';
                // Close claw
                claw.children.forEach(arm => {
                    arm.rotation.x = Math.PI / 4;
                });
            }
        } else if (clawState === 'rising' || clawState === 'holding') {
            clawBase.position.y += clawSpeed;
            if (heldPrize) {
                updatePrizePosition();
            }
            if (clawBase.position.y >= initialClawHeight) {
                if (heldPrize) {
                    collectPrize();
                }
                clawState = 'idle';
                // Open claw
                claw.children.forEach(arm => {
                    arm.rotation.x = 0;
                });
            }
        }

        // Calculate square viewport dimensions
        const totalWidth = window.innerWidth;
        const height = window.innerHeight;

        // Main view (left side - 2/3 width)
        const mainViewWidth = totalWidth * 2/3;
        const mainViewSize = Math.min(mainViewWidth, height);
        const mainViewX = (mainViewWidth - mainViewSize) / 2;
        const mainViewY = (height - mainViewSize) / 2;

        // Top view (right side - 1/3 width)
        const topViewWidth = totalWidth * 1/3;
        const topViewSize = Math.min(topViewWidth, height);
        const topViewX = mainViewWidth + (topViewWidth - topViewSize) / 2;
        const topViewY = (height - topViewSize) / 2;

        // Render main view
        renderer.setViewport(mainViewX, mainViewY, mainViewSize, mainViewSize);
        renderer.setScissor(mainViewX, mainViewY, mainViewSize, mainViewSize);
        renderer.setScissorTest(true);
        renderer.render(scene, mainCamera);

        // Render top view
        renderer.setViewport(topViewX, topViewY, topViewSize, topViewSize);
        renderer.setScissor(topViewX, topViewY, topViewSize, topViewSize);
        renderer.setScissorTest(true);
        renderer.render(scene, topCamera);
    }
</script>
</body>
</html>